\documentclass[a4paper, 12pt]{article}

\usepackage{packages}

\title{АиСД, пилотный поток. Лекция 3.}
\author{}
\date{}

\begin{document}
\lstset{numbers=left}
    \maketitle
        Алгоритм считается правильным, если выполнены два условия:
    \begin{itemize}
        \item если алгоритм завершился, то получено корректное решение исходной задачи;
        \item на любом допустимом входе алгоритм заканчивает работу (завершаемость алгоритма).
    \end{itemize}

Вычислительная модель, в которой рассматриваем алгоритмы (упрощенная RAM-модель):
\begin{itemize}
    \item Программа и память разделены. Используем одноранговуюя память, умеем обращаться к произвольной ячеке памяти, любую ячейку памяти можно адресовать.
    \item Операция получения памяти происходит за время, пропорциональное размеру этой памяти.
    \item Диапазон хранимых чисел. Параметр с --- ограничение на входные данные. Все числа не превосходят с. n --- количество данных.
Если алгоритм является сильно полиномиальным, и размер чисел никак не влияет на время работы алгоритма, то с не будет участвовать в описании сложности данного алгоритма.
Все промежуточные значения, которыми разрешено пользоваться не превосходят $n^kc^k$.
  \end{itemize}

Разрешенные операции в рамках данной вычислительной модели:
    \begin{itemize}
        \item Условная передача управления (бинарные ветвления)
        \item Обращение в память
        \item Арифметические оперции
        \item Логические операции
        \item Битовые операции
        \item Математические операции
    \end{itemize}

\subsection*{Доказательство корректности алгоритма}

Существует 3 способа доказательства корректности алгоритма:
    \begin{itemize}
        \item от противного
        \item по индукции
        \item по инварианту (Т. е. существует некоторое условие, которое выполнено в начале программы,  выполнено после каждого шага алгоритма, и выполнение этого условия в конце работы программы обеспечивает корректность ответа)
    \end{itemize}

Рассмотрим 3 алгоритма квадратичной сортировки: сортировку пузырьком, выбором и вставками.

\subsubsection*{Bubble sort. Доказательство от противного.}

Алгоритм:
\begin{lstlisting}
while not a.is_sorted():
    for i: 1..n:
        if a[i]>a[i+1]:
            swap(a[i], a[i+1])
\end{lstlisting}

Пусть алгоритм завершился, а массив не отсортирован, но цикл (1)
завершается только тогда, когда массив отсортирован. Теперь докажем, что алгоритм всегда завершится. Во внутреннем цикле всегда хотя бы один раз выполняется 4-ая строка. Таким образом, каждый раз уменьшается число инверсий. Значит, цикл обязательно завершится. Доказано, что алгоритм всегда завершается при корректных входных данных, а если завершается, то массив a отсортирован.

\subsubsection*{Selection sort. Доказательство по индукции.}
Алгоритм:
\begin{lstlisting}[firstnumber=1]
go(n, a)
    if n = 1:
        return a
    p = max_position(a)
    swap(a[p],a[n])
    b = go(n-1, a[1:n-1])
    return concat(b, a[n])
\end{lstlisting}

Массив длины 1 алгоритм сортирует верно (строки 2-3). Пусть алгоритм верно сортирует массив длины, меньшей n. Тогда проверим правильность алгоритма для массива длины n. В строке 4 выбирается индекс максимума массива, затем максимум ставится на n-ую позицию (строка 5). Теперь a[n] не меньше любого элемента среди первых n-1 элементов. Так как алгоритм для массива длины n-1 работает верно, то после добавления к отсортированному масиву элемента a[n] (строка 7) получаем тоже отсортированный массив. Следовательно, массив длины n тоже корректно сортируется.

\subsubsection*{Insertion sort. Доказательство по инварианту.}
Алгоритм:
\begin{lstlisting}[firstnumber=1]
sort(n, a)
    for i:1..n:
        j = i
        while (i>=2 and a[j-1]>a[j])
            swap(a[j], a[j-1])
            j-=1
\end{lstlisting}

Введём инвариант: после i шагов внешнего цикла префикс длины i(т.е. a[1:i]) отсортирован. Очевидно, что после первого шага инвариант выполнен, массив длины 1 отсортрован. Ясно, что выполнение в конце при i = n является условием отсортированности всего массива. Внутрення процедура выполняет вставку элемента в отсортированный массив. При этом она не меняет относительно порядка элементов, а элемент, "проталкиваемый" процедурой становится на j-ую позицию так, что $(j-1=0) \lor (a[j-1] \leqslant a[j]) \land (j+1 > i) \lor (a[j+1]>a[j]$).

\subsection*{Оценка времени работы алгоритма}

Существует три основных способа оценки времени работы алгоритма:
\begin{itemize}
    \item Прямой учет
    \item Метод потенциалов
    \item Оценка рекуррент
\end{itemize}

Метод прямого учета предъявляет верхнюю оценку на то, сколько раз выполнится каждая строка алгоритма. Используется, если алгоритм не содержит рекурсивных процедур.


\subsubsection*{Merge sort. Оценка рекуррент. Дерево рекурсии}
Алгоритм:
\begin{lstlisting}[firstnumber=1]
sort(n, a)
    if n = 1:
        return
    b = a[1..n/2]
    c = a[n/2+1..n]
    b1 = sort(n/2, b)
    c1 = sort(n-n/2, c)
    return merge(b1, c1)
\end{lstlisting}

Выписываем время работы как рекурсивную функцию. t(n) --- количество действий, которые придется проделатьна данном уровне + действия рекурсивных вызовов. $t(n) = \Theta(n) + 2 \cdot t (\frac{n}{2}$).
Нужно показать, что возможно выбрать c = const, такое что $t(n) \leqslant c \cdot n\cdot \log n$. Очевидно, что на массиве размера 1 возможно. Покажем индукционный переход. Пусть для массива размера, меньшего n, выполнено. Покажем, что верно и для n.
 $\Theta(n) + 2 \cdot t (\frac{n}{2}) \leqslant a\cdot n+2 \cdot c \cdot \frac{n}{2} \cdot \log{\frac{n}{2}}= a\cdot n +c \cdot n \cdot (\log n - 1) = a \cdot n + c \cdot n \cdot \log n - c \cdot n \leqslant c \cdot n \cdot \log$. Это верно, если выбираем c, большее~a.
(Константа a происходит из $\Theta$.)

\end{document}
